@page "/"
@rendermode InteractiveServer
@using instech_blazor_coding_task.Models
@using instech_blazor_coding_task.Services
@inject IDragService DragService
@inject IPositionService PositionService
@inject IVesselLayoutService VesselLayoutService
@inject IRotationService RotationService
@inject IVesselTrackingService VesselTrackingService
@inject IApiService ApiService

<PageTitle>Bin packing problem</PageTitle>

@* The OnDragMove method updates the position of the element being dragged relative to the page.
Therefore the first element has to handle it. *@
<div @onmousemove="OnDragMove">
    <PageHeader OnTryAgainClick="GenerateNewVessels" />

    @if (_vessels == null)
    {
        <div>Loading...</div>
    }
    else
    {
        <div class="game-area">
            <AnchorageBox Width="_anchorageWidth" Height="_anchorageHeight" />
            
            @foreach (var vessel in _vessels)
            {
                <VesselItem 
                    Vessel="vessel" 
                    OnMouseDown="@(e => OnDragStart(vessel, e))"
                    OnMouseUp="@(() => OnDragEnd(_vessels))"
                    OnDoubleClick="@(() => OnVesselDoubleClick(vessel))" />
            }
        </div>

        <div class="instructions-card" style="width: @(_anchorageWidth - 100)px;">
            <div class="instructions-title">Instructions</div>
            <ul class="instructions-list">
                <li class="instruction-item">
                    <span class="instruction-number">1</span>
                    <span class="instruction-text">Click and hold on any vessel (pink rectangles) on the right</span>
                </li>
                <li class="instruction-item">
                    <span class="instruction-number">2</span>
                    <span class="instruction-text">Drag the vessel into the blue anchorage</span>
                </li>
                <li class="instruction-item">
                    <span class="instruction-number">3</span>
                    <span class="instruction-text">Double-click on a vessel to rotate it 90 degrees</span>
                </li>
                <li class="instruction-item">
                    <span class="instruction-number">4</span>
                    <span class="instruction-text">Vessels cannot overlap with each other</span>
                </li>
                <li class="instruction-item">
                    <span class="instruction-number">5</span>
                    <span class="instruction-text">Place all vessels completely inside the anchorage to win</span>
                </li>
                <li class="instruction-item">
                    <span class="instruction-number">6</span>
                    <span class="instruction-text">Some combinations of vessels might not fit into the anchorage in any combination. In that case try again</span>
                </li>
            </ul>
        </div>
        
        <VesselTracker TrackingInfo="VesselTrackingService.GetTrackingInfo()" />
        
        <SuccessMessage IsVisible="_anchorageFull" />
    }
</div>

@code {
private double _anchorageWidth = 500;

private double _anchorageHeight = 500;

private List<Vessel>? _vessels = [];

private bool _anchorageFull = false;

private DateTime _lastRotationTime = DateTime.MinValue;
private const int RotationDebounceMs = 300;

    protected override async Task OnInitializedAsync()
    {
        await LoadVesselsFromApi();
    }

    private async Task LoadVesselsFromApi()
    {
        try
        {
            var response = await ApiService.GetRandomFleetAsync();

            if (response == null)
            {
                Console.WriteLine("Failed to fetch fleet data");
                return;
            }
            
            // Update anchorage dimensions from API
            if (response.AnchorageSize != null)
            {
                _anchorageHeight = response.AnchorageSize.Height * 20;
                _anchorageWidth = response.AnchorageSize.Width * 20;
            }

            // Delegate vessel layout to the VesselLayoutService
            _vessels = VesselLayoutService.GenerateVesselLayout(response.Fleets, _anchorageWidth);
            
            // Initialize vessel tracking
            VesselTrackingService.Initialize(response.Fleets);
            UpdateTracking();
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error loading vessels: " + ex.Message);
        }
    }

private void OnDragStart(Vessel vessel, MouseEventArgs e) {
    DragService.OnDragStart(vessel, e);
}

private void OnDragMove(MouseEventArgs e) {
    DragService.OnDragMove(e);
}

private void OnDragEnd(IEnumerable<Vessel> allVessels) {
    DragService.OnDragEnd(allVessels, PositionService);
    
    var anchorage = new Anchorage { Width = _anchorageWidth, Height = _anchorageHeight };
    _anchorageFull = PositionService.AllVesselsInAnchorage(allVessels, anchorage);
    
    UpdateTracking();
}

private void UpdateTracking() {
    var anchorage = new Anchorage { Width = _anchorageWidth, Height = _anchorageHeight };
    VesselTrackingService.UpdateTracking(_vessels ?? [], anchorage, PositionService);
}

private async Task GenerateNewVessels() {
    _anchorageFull = false;
    _vessels = null;
    await LoadVesselsFromApi();
}

private void OnVesselDoubleClick(Vessel vessel) {
    // Prevent multiple rotations in a short time period
    var now = DateTime.Now;
    if ((now - _lastRotationTime).TotalMilliseconds < RotationDebounceMs)
    {
        return;
    }
    
    _lastRotationTime = now;
    RotationService.RotateVessel(vessel);
    StateHasChanged();
}
}